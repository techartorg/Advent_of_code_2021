"""
Python day12
"""

import collections
import string

from utils.solver import ProblemSolver


class Cave(object):
    Small = 0
    Large = 1

    def __init__(self, caveID=None, size=Small):
        self._id = caveID
        self.size = size
        self.connections = []

    @property
    def ID(self):
        return self._id

    @ID.setter
    def ID(self, value):
        self._id = value
        self.size = int(self._id[0] in string.ascii_uppercase)

    def addConnection(self, caveID):
        """
        Register a new connection from this cave to somewhere else

        :param str caveID: The ID of the cave to which this cave connects
        """
        if caveID not in self.connections:
            self.connections.append(caveID)

    def __repr__(self):
        return 'Cave(caveID={}, size={})'.format(self.ID, self.size)


class Path(list):
    def __init__(self, *args, hasRevisited=False, **kwargs):
        super(Path, self).__init__(*args, **kwargs)
        self.hasRevisitedSmallCave = hasRevisited

    def canVisit(self, cave, revisitCave):
        """
        Returns true if this path can visit the input cave

        :param Cave cave: the cave to test
        :param str revisitCave: the id of the cave we're allowed to revisit

        :return bool:
        """
        # if the cave is small, chelf a couple other things
        if cave.size == Cave.Small:
            # if we haven't visited the cave, return True
            if cave.ID not in self:
                return True
            # otherwise, if the cave we're trying to visit is the revisit cave
            # AND we haven't already visited it
            elif cave.ID == revisitCave and not self.hasRevisitedSmallCave:
                self.hasRevisitedSmallCave = True
                return True
        # if the cave is big, then we can return to it
        else:
            return True

    def moveTo(self, location):
        newSelf = Path(self, hasRevisited=self.hasRevisitedSmallCave)
        newSelf.append(location)
        return newSelf

    def isTerminal(self):
        """
        :returns bool: If this path has reached the end
        """
        return self[-1] == 'end'


class day12Solver(ProblemSolver):
    def __init__(self):
        super(day12Solver, self).__init__(12)

        self.testDataPartOne = {'''start-A
start-b
A-c
A-b
b-d
A-end
b-end''': 10,
                                '''dc-end
HN-start
start-kj
dc-start
dc-HN
LN-dc
HN-end
kj-sa
kj-HN
kj-dc''':19,
                                '''fs-end
he-DX
fs-he
start-DX
pj-DX
end-zg
zg-sl
zg-pj
pj-he
RW-he
fs-DX
pj-RW
zg-RW
start-pj
he-WI
zg-he
pj-fs
start-RW''':226}
        self.testDataPartTwo = {list(self.testDataPartOne.keys())[0]: 36,
                                list(self.testDataPartOne.keys())[1]:103,
                                list(self.testDataPartOne.keys())[2]:3509}

    def ProcessInput(self, data=None):
        """
        
        :param data:
        :returns: processed data for today's challenge
        """
        if not data:
            data = self.rawData

        processed = collections.defaultdict(Cave)
        for line in data.split('\n'):
            beginning, end = line.split('-')
            processed[beginning].addConnection(end)
            processed[end].addConnection(beginning)

        # make sure the caves update their ID, since we created them with a default dict
        for caveID in processed:
            processed[caveID].ID = caveID

        return processed

    def solvePaths(self, data, revisit=None):
        """
        Loop through all the possible paths to find
        the set of terminal paths that exist in the data set
        without revisiting any small caves

        :param dict{str: Cave}: the cave system to parse
        :param str revisit: the cave which can be revisited in this solver

        :return list[Path]: all the paths generated by solving the input cave system
        """
        start = Path()
        start.append('start')
        paths = [start]
        terminalPaths = []

        # while we still have paths to search
        while paths:
            newPaths = []
            for i, path in enumerate(paths):
                path = paths[i]
                location = path[-1]
                # if the path has arrived at the end, move it over to the list of terminal paths
                if path.isTerminal():
                    terminalPaths.append(path)
                # otherwise, create new paths for each valid connection
                # in the connections from our current location
                else:
                    for connection in data[location].connections:
                        # if the connection meets criteria
                        if path.canVisit(data[connection], revisit):
                            newPaths.append(path.moveTo(connection))

            paths = newPaths  # move our new paths over to the paths variable

        return terminalPaths

    def SolvePartOne(self, data=None):
        """
        
        :param data:
        :returns: The solution to today's challenge
        """
        if not data:
            data = self.processed

        terminalPaths = self.solvePaths(data)

        return len(terminalPaths)

    def SolvePartTwo(self, data=None):
        """
        
        :param data:
        :returns: The solution to part two of today's challenge
        """
        if not data:
            data = self.processed

        paths = self.solvePaths(data)
        # all the small caves, except Start and End
        smallCaves = [k for k in list(data.keys()) if k[0] in string.ascii_lowercase and k != 'start' and k != 'end']
        for cave in smallCaves:
            paths += self.solvePaths(data, revisit=cave)

        outPaths = []
        for path in paths:
            if path not in outPaths:
                outPaths.append(path)

        for path in outPaths:
            print(path)

        return len(outPaths)


def Test():
    day12.processed = day12.ProcessInput(data='''start-A
start-b
A-c
A-b
b-d
A-end
b-end''')
    out = day12.solvePaths(day12.processed, 'c')
    for i in out:
        if len(i) > 4:
            if i[4] == 'b':
                print(i)

# for some reason, we're only getting these two cases of AcAb:
#['start', 'A', 'c', 'A', 'b', 'end']
#['start', 'A', 'c', 'A', 'b', 'A', 'end']
# and missing this one:
# 'start,A,c,A,b,A,c,A,end'
# so why, when we're working on the second path case, are we not then going back to c even though it's a valid
# revisit target?

if __name__ == '__main__':
    day12 = day12Solver()
    #day12.Run()
    Test()
